---
title: "Data Science עם R - פרק 4 - קריאת נתונים, טרנספורמציות, ותכנות פונקציונלי באמצעות tidyverse"
author: "עדי שריד"
output: html_document
---

```{css, echo=FALSE}
p, h1, h2, h3, h4, ul, ol {
  direction: rtl;
}
```

## טרנספורמציה של נתונים

כפי שראינו בחלק הראשון חלק ניכר מהעבודה של Data Scientists הוא ניקוי וסידור נתונים.
חבילות dplyr, tidyr, נבנו כדי לספק סט כלים רחב שמסייע בכלל פעילויות אלו, באופן אינטואיטיבי ויעיל.

ראשית, נטען חבילות אלו ונקרא את קובץ הנתונים עמו עבדנו בפרקים הקודמים.

```{r read-data, warning=FALSE, message=FALSE}
# You can specifically call the two:
#library(dplyr)
#library(tidyr)
# But I usually load tidyverse which takes care of everything:
library(tidyverse)

kaggle.survey17 <- readr::read_csv("01-data/kaggle-survey-2017/multipleChoiceResponses.csv")

glimpse(kaggle.survey17)

```

פקודת `glimpse` שבה השתמשנו גם שייכת ל-dplyr והיא מספקת "הצצה" לתוך הנתונים.
באמצעות הפקודה אנחנו רואים את השדות השונים שנמצאים בקובץ שקראנו, מאיזה סוג הם, ומספר ערכים ראשונים בכל שדה.

### פקודת `select`


הפקודה הבאה שנלמד היא `select`, פקודה זו מאפשרת לנו לבחור רק משתנים מסוימים, וכך לעבוד עם מבנה נתונים נקי יותר.

```{r select}

work_challenge <- select(kaggle.survey17, starts_with("WorkChallenge"), GenderSelect, Age, EmploymentStatus)
glimpse(work_challenge)

```

בקוד המוצג לעיל הפעלנו את פונקצית `select` כדי לבחור את כל המשתנים מתוך `kaggle.survey17`, ששמותיהם מתחילים ב-"WorkChallenge", ביחד עם משתני המגדר, גיל, ומצב תעסוקה. על זה הפעלנו את פקודת `glimpse`. אנו רואים שכמות המשתנים קטנה מ-228 ל-26 המשתנים הרלוונטיים.

הפקודה `select` רובוסטית בכך שהיא מאפשרת לנו לבחור על ידי ציון שם המשתנה הספציפי או חלק מההתחלה שלו (starts_with), הסוף שלו (ends_with) או חלק שהוא מכיל (contains).

דרך נוספת להשתמש בפונקציית `select` היא באמצעות אופרטור המקטרת, pipe, שנראה כך `%>%`, המאפשר לנו לשרשר פקודות אחת אחרי השניה, והופך את הקוד שלנו להרבה יותר קריא. לדוגמה, שקול לשורת הקוד הקודמת יראה כך:

```
kaggle.survey17 %>%
   select(starts_with("WorkChallenge")) %>%
   glimpse()
```
אופרטור המקטרת דואג להעביר לכל פונקציה בשרשרת את התוצאה של הפונקציה הקודמת. כך מבנה הנתונים עובר לתוך `select` ותוצר הפקודה `select` עובר לתוך `glimpse`. מעתה נשתמש באופרטור זה כאשר מדובר בשרשראות של פקודות מ-dplyr ומ-tidyr.

פונקציית העזר `start_with` עוזרת לנו לדלות את כל המשתנים ששמם מתחיל במחרוזת "WorkChallenge". פונקציות עזר נוספות כוללות:

```
starts_with(match)
ends_with(match)
matches(match)
contains(match)
one_of(...) # variables in character vector
matches(regex_str) # match a regular expression

```

***
### תרגיל

   1. קרא את קובץ הנתונים עמו עבדנו בפרק הקודם (googleplaystore.csv), והצץ בנתונים. כמה משתנים יש בקובץ?
   2. אילו משתנים ישנם בקובץ שהם משתני מחרוזת אבל היו יכולים להיות מספריים?
   3. בחר את כל המשתנים שמסתיימים במילה "Ver",  ביחד עם כל המשתנים שמכילים את האות הגדולה "R". כמה משתנים קיבלת?



```{r read-googleplaystore, warning=FALSE, message=FALSE, fig.width=10, include=FALSE}
library(tidyr)
library(dplyr)
google_play <- readr::read_csv(file = "02-data/googleplaystore.csv")
glimpse(google_play)
google_play_ver <- google_play %>% 
  select(ends_with("Ver"), contains("R", ignore.case = FALSE))
```   

***

### פקודת `filter`

פקודת `filter` מאפשרת לנו לסנן נתונים לפי קריטריונים (תנאים לוגיים)
לדוגמה, כדי לסנן רק אפליקציות עם דירוג ממוצע מעל 4 או מתחת ל-2 נשתמש בפקודה:

```
google_play %>%
   filter(Rating > 4 | Rating < 2)
```

כדי לסנן רק את האפליקציות מקטגורית משפחה נשתמש בפקודה

```
google_play %>%
   filter(Category == "FAMILY")
```

ניתן גם להשתמש בתנאים מורכבים יותר או לשרשר תנאים באופן הבא:

```{r multiple criteria}

# Best option, but a matter of personal flavour
google_play %>%
  filter(Rating > 4 | Rating <2) %>%
  filter(Category == "FAMILY")

# Also ok, same result. Multiple criteria within filter as seperate arguments, also treated as "and"
google_play %>%
  filter(Rating > 4 | Rating <2, 
         Category == "FAMILY")

# Less readable but still the same
google_play %>%
  filter((Rating > 4 | Rating <2) & (Category == "FAMILY"))
```

***

### תרגיל

ב-R ישנם שני סוגים של אופרטורים לוגיים מסוג "או" ושני סוגים של אופרטרים לוגיים מסוג "וגם". בתרגיל זה נבין מהם ההבדלים ביניהם ונתרגל את פונקציית filter.

   1. בנו את הוקטורים הבאים: 

```
vec1 <- c(TRUE, TRUE, FALSE, TRUE)
vec2 <- c(FALSE, TRUE, TRUE FALSE)
```

   2.בדקו מה ההבדל בין שתי הגרסאות הבאות

```
vec1 | vec2
# versus
vec1 || vec2

vec1 & vec2
#versus
vec1 && vec2

```

   3. הסבירו, מה עושה אופרטור כפול לעומת אופרטור בודד?